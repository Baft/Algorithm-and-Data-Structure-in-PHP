#PHP-belman-ford-shortest-path

<h2>Introduction</h2>
<p>As we saw in the previous post, <a title="Computer Algorithms: Dijkstra Shortest Path in a Graph" href="http://www.stoimen.com/blog/2012/10/15/computer-algorithms-dijkstra-shortest-path-in-a-graph/">the algorithm of Dijkstra</a> is very useful when it comes to find all the shortest paths in a weighted graph. However it has one major problem! Obviously it doesn’t work correctly when dealing with negative lengths of the edges.</p>
<p>We know that the algorithm works perfectly when it comes to positive edges, and that is absolutely normal because we try to optimize the inequality of the triangle.</p>
<figure id="attachment_3420" style="width: 620px;" class="wp-caption alignnone"><a href="http://www.stoimen.com/blog/wp-content/uploads/2012/10/1.-Dijkstras-Approach.png"><img class="size-full wp-image-3420" title="Dijkstra's Approach" src="http://www.stoimen.com/blog/wp-content/uploads/2012/10/1.-Dijkstras-Approach.png" alt="Dijkstra's Approach" height="399" width="620"></a><figcaption class="wp-caption-text">Since all the edges are positive we get the closest one!</figcaption></figure>
<p>Since Dijkstra’s algorithm make use of a priority queue normally we get first the shortest adjacent edge to the starting point. In our very basic example we’ll get first the edge with the length of 3 -&gt; (S, A).</p>
<p>However when it comes to negative edges we can’t use any more priority queues, so we need a different, yet working solution.<span id="more-3417"></span></p>
<h2>Overview</h2>
<p>The solution was published by <a title="Richard E. Bellman" href="http://en.wikipedia.org/wiki/Richard_Bellman" target="_blank">Richard E. Bellman</a> and <a title="Lester Ford, Jr." href="http://en.wikipedia.org/wiki/L._R._Ford,_Jr." target="_blank">Lester Ford, Jr.</a> in 1958 in their publication “On a Routing Problem” and it is quite simple to explain and understand. Since we can prioritize the edges by its lengths the only thing we should do is to calculate <span style="text-decoration: underline;">all</span> the paths. And to be sure that our algorithm will find all the paths correctly we repeat that N-1 times, where N is the number of vertices (|V| = N)!</p>
<figure id="attachment_3421" style="width: 620px;" class="wp-caption alignnone"><a href="http://www.stoimen.com/blog/wp-content/uploads/2012/10/2.-Bellman-Ford-Approach.png"><img src="http://www.stoimen.com/blog/wp-content/uploads/2012/10/2.-Bellman-Ford-Approach.png" alt="Bellman-Ford Approach" title="Bellman-Ford Approach" class="size-full wp-image-3421" height="399" width="620"></a><figcaption class="wp-caption-text">The algorithm of Bellman-Ford doesn’t use priority queues! Indeed they are useless since the closest node in the queue can have shorter path passing through another node!</figcaption></figure>
<p>In this very basic image we can see how Bellman-Ford solves the problem. First we get the distances from S to A and B, which are respectively 3 and 4, but there is a shorter path to A, which passes through B and it is (S, B) + (B, A) = 4 – 2 = 2.</p>

<h2>Application</h2>
<p>Actually this algorithm is very useful and it not only works with negative weights, but also can help us find negative cycles in the graph.</p>
<figure id="attachment_3422" style="width: 620px;" class="wp-caption alignnone"><a href="http://www.stoimen.com/blog/wp-content/uploads/2012/10/3.-Negative-Cycles.png"><img src="http://www.stoimen.com/blog/wp-content/uploads/2012/10/3.-Negative-Cycles.png" alt="Negative Cycles" title="Negative Cycles" class="size-full wp-image-3422" height="399" width="620"></a><figcaption class="wp-caption-text">A negative cycle can be found with Bellman-Ford’s algorithm!</figcaption>
