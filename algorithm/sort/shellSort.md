#php-shell-sort
<h2>Overview</h2>
<p><a href="http://www.stoimen.com/blog/2012/02/13/computer-algorithms-insertion-sort/" title="Computer Algorithms: Insertion Sort">Insertion sort</a> is a great algorithm, because it’s very intuitive and it is easy to implement, but the problem is that it makes many exchanges for each “light” element in order to put it on the right place. Thus “light” elements at the end of the list may slow down the performance of insertion sort a lot. That is why in 1959 <a href="http://en.wikipedia.org/wiki/Donald_Shell" title="Donald Shell" target="_blank">Donald Shell</a> proposed an algorithm that tries to overcome this problem by comparing items of the list that lie far apart.</p>
<figure id="attachment_2796" style="width: 620px;" class="wp-caption alignnone"><a href="http://www.stoimen.com/blog/wp-content/uploads/2012/02/Insertion-Sort-vs.-Shell-Sort.png"><img src="http://www.stoimen.com/blog/wp-content/uploads/2012/02/Insertion-Sort-vs.-Shell-Sort.png" alt="Insertion Sort vs. Shell Sort" title="Insertion Sort vs. Shell Sort" class="size-full wp-image-2796" width="620"></a><figcaption class="wp-caption-text">Insertion sort compares every single item with all the rest elements of the list in order to find its place, while Shell sort compares items that lie far apart. This makes light elements to move faster to the front of the list.</figcaption></figure>
<p>In the other hand it is obvious that by comparing items that lie apart the list can’t be sorted in one pass as insertion sort. That is why on each pass we should use a fixed gap between the items, then decrease the value on every consecutive iteration.<span id="more-2734"></span></p>
<figure id="attachment_2791" style="width: 620px;" class="wp-caption alignnone"><a href="http://www.stoimen.com/blog/wp-content/uploads/2012/02/Shell-Sort.png"><img src="http://www.stoimen.com/blog/wp-content/uploads/2012/02/Shell-Sort.png" alt="Shell Sort" title="Shell Sort" class="size-full wp-image-2791" width="620"></a><figcaption class="wp-caption-text">We start to compare items with a fixed gap, that becomes lesser on each iteration until it gets to 1.</figcaption></figure>
<p>However it is intuitively clear that Shell sort may need even more comparisons than insertion sort. Then why should we use it? </p>
<p>The thing is that insertion sort is not an effective sorting algorithm at all, but in some cases, when the list is almost sorted it can be quite useful. Here’s the answer of the question above. With Shell sort once the list is sorted for gap = i, it is sorted for every gap = j, where j &lt; i, and this is its main advantage.

[caption id="attachment_2792" align="alignnone" width="620" caption="Shell sort can make less exchanges than insertion sort."]<a href="http://www.stoimen.com/blog/wp-content/uploads/2012/02/Shell-Sort-Principles.png"><img src="http://www.stoimen.com/blog/wp-content/uploads/2012/02/Shell-Sort-Principles.png" alt="Shell Sort Principles" title="Shell Sort Principles" class="size-full wp-image-2792" width="620"></a>[/caption]</p>
<h3>How to choose gap size</h3>
<p>Not a cool thing about Shell sort is that we’ve to choose “the perfect” gap sequence for our list. However this is not an easy task, because it depends a lot of the input data. The good news is that there are some gap sequences proved to be working well in the general cases.</p>
<h3>Shell Sequence</h3>
<p>Donald Shell proposes a sequence that follows the formula FLOOR(N/2<sup>k</sup>), then for N = 1000, we get the following sequence: [500, 250, 125, 62, 31, 15, 7, 3, 1]</p>
<figure id="attachment_2793" style="width: 620px;" class="wp-caption alignnone"><a href="http://www.stoimen.com/blog/wp-content/uploads/2012/02/Shell-Gap-Sequence.png"><img src="http://www.stoimen.com/blog/wp-content/uploads/2012/02/Shell-Gap-Sequence.png" alt="Shell Gap Sequence" title="Shell Gap Sequence" class="size-full wp-image-2793" width="620"></a><figcaption class="wp-caption-text">Shell sequence for N=1000: (500, 250, 125, 62, 31, 15, 7, 3, 1)</figcaption></figure>
<h3>Pratt Sequence</h3>
<p><a href="http://en.wikipedia.org/wiki/Vaughan_Ronald_Pratt" title="Vaughan Pratt" target="_blank">Pratt</a> proposes another sequence that’s growing with a slower pace than the Shell’s sequence. He proposes successive numbers of the form 2<sup>p</sup>3<sup>q</sup> or [1, 2, 3, 4, 6, 8, 9, 12, …].</p>
<figure id="attachment_2794" style="width: 620px;" class="wp-caption alignnone"><a href="http://www.stoimen.com/blog/wp-content/uploads/2012/02/Pratt-Gap-Sequence.png"><img src="http://www.stoimen.com/blog/wp-content/uploads/2012/02/Pratt-Gap-Sequence.png" alt="Pratt Gap Sequence" title="Pratt Gap Sequence" class="size-full wp-image-2794" width="620"></a><figcaption class="wp-caption-text">Pratt sequence: (1, 2, 3, 4, 6, 8, 9, 12, ...)</figcaption></figure>
<h3>Knuth Sequence</h3>
<p>Knuth in other hand proposes his own sequence following the formula (3<sup>k</sup> – 1) / 2 or [1, 4, 14, 40, 121, …]</p>
<figure id="attachment_2795" style="width: 620px;" class="wp-caption alignnone"><a href="http://www.stoimen.com/blog/wp-content/uploads/2012/02/Knuth-Gap-Sequence.png"><img src="http://www.stoimen.com/blog/wp-content/uploads/2012/02/Knuth-Gap-Sequence.png" alt="Knuth Gap Sequence" title="Knuth Gap Sequence" class="size-full wp-image-2795" width="620"></a><figcaption class="wp-caption-text">Knuth sequence: (1, 4, 13, 40, 121, ...)</figcaption></figure>
<p>Of course there are many other gap sequences, proposed by various developers and researchers, but the problem is that the effectiveness of the algorithm strongly depends on the input data. But before taking a look to the complexity of Shell sort, let’s see first its implementation.</p>

<h2>Complexity</h2>
<p>Yet again we can’t determine the exact complexity of this algorithm, because it depends on the gap sequence. However we may say what is the complexity of Shell sort with the sequences of Knuth, Pratt and Donald Shell. For the Shell’s sequence the complexity is O(n<sup>2</sup>), while for the Pratt’s sequence it is O(n*log<sup>2</sup>(n)). The best approach is the Knuth sequence where the complexity is O(n<sup>3/2</sup>), as you can see on the diagram bellow.</p>
<figure id="attachment_2797" style="width: 620px;" class="wp-caption alignnone"><a href="http://www.stoimen.com/blog/wp-content/uploads/2012/02/Complexity-of-Shell-Sort.png"><img src="http://www.stoimen.com/blog/wp-content/uploads/2012/02/Complexity-of-Shell-Sort.png" alt="Complexity of Shell Sort" title="Complexity of Shell Sort" class="size-full wp-image-2797" width="620"></a><figcaption class="wp-caption-text">Complexity of Shell sort with different gap sequences.</figcaption></figure>
<h2>Application</h2>
<p>Well, as insertion sort and bubble sort, Shell sort is not very effective compared to quicksort or merge sort. The good thing is that it is quite easy to implement (not easier than insertion sort), but in general it should be avoided for large data sets. Perhaps the main advantage of Shell sort is that the list can be sorted for a gap greater than 1 and thus making less exchanges than insertion sort. </p>

source : http://www.stoimen.com/blog/2012/02/27/computer-algorithms-shell-sort/
